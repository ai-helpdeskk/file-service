# .github/workflows/file-service-cd.yml
name: File Service - CD

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
        - staging
        - production
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
  repository_dispatch:
    types: [deploy-file-service]

env:
  SERVICE_NAME: file-service
  IMAGE_NAME: samitsinghhh/file-service
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.event.client_payload.environment || 'staging' }}
    
    steps:
      - name: Set deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            ENVIRONMENT="${{ github.event.client_payload.environment }}"
            IMAGE_TAG="${{ github.event.client_payload.image_tag }}"
          else
            ENVIRONMENT="staging"
            IMAGE_TAG="latest"
          fi
          
          if [ "$ENVIRONMENT" = "production" ]; then
            NAMESPACE="bedrock-chat-v2"
          else
            NAMESPACE="bedrock-chat-staging"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "full_image=${{ env.IMAGE_NAME }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          echo "üöÄ Deployment Configuration:"
          echo "- Environment: $ENVIRONMENT"
          echo "- Namespace: $NAMESPACE"
          echo "- Image Tag: $IMAGE_TAG"
          echo "- Full Image: ${{ env.IMAGE_NAME }}:$IMAGE_TAG"

      - name: Checkout k8s manifests
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/k8s-manifests
          token: ${{ secrets.MANIFEST_REPO_TOKEN }}
          path: k8s-manifests

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          if [ -z "${{ env.KUBE_CONFIG_DATA }}" ]; then
            echo "‚ùå KUBE_CONFIG_DATA secret not found!"
            exit 1
          fi
          
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          chmod 600 kubeconfig
          
          kubectl cluster-info --request-timeout=30s
          echo "‚úÖ Connected to Kubernetes cluster"

      - name: Update deployment manifest
        run: |
          cd k8s-manifests
          
          DEPLOYMENT_FILE=""
          POSSIBLE_PATHS=(
            "k8s/deployments/file-service-deployment.yaml"
            "deployments/file-service-deployment.yaml"
            "manifests/file-service-deployment.yaml"
          )
          
          DEPLOYMENT_FILE=""
          POSSIBLE_PATHS=(
            "k8s/deployments/file-service-deployment.yaml"
            "deployments/file-service-deployment.yaml"
            "manifests/file-service-deployment.yaml"
          )
          
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DEPLOYMENT_FILE="$path"
              echo "Found deployment file: $path"
              break
            fi
          done
          
          if [ -z "$DEPLOYMENT_FILE" ]; then
            echo "‚ùå File Service deployment file not found!"
            echo "Available files:"
            find . -name "*file-service*.yaml" -type f || echo "No File Service files found"
            exit 1
          fi
          
          echo "üìù Updating image in $DEPLOYMENT_FILE"
          echo "From: $(grep -n "image:" "$DEPLOYMENT_FILE" | head -1)"
          
          # Update image tag
          sed -i "s|image: samitsinghhh/file-service:.*|image: ${{ steps.params.outputs.full_image }}|g" "$DEPLOYMENT_FILE"
          
          echo "To: $(grep -n "image:" "$DEPLOYMENT_FILE" | head -1)"
          echo "‚úÖ Manifest updated successfully"

      - name: Create namespace
        run: |
          export KUBECONFIG=kubeconfig
          kubectl create namespace ${{ steps.params.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Namespace ready: ${{ steps.params.outputs.namespace }}"

      - name: Apply supporting resources
        run: |
          export KUBECONFIG=kubeconfig
          cd k8s-manifests
          
          # Apply ConfigMaps
          if [ -d "k8s/configmaps" ]; then
            echo "üìã Applying ConfigMaps..."
            kubectl apply -f k8s/configmaps/ -n ${{ steps.params.outputs.namespace }} || true
          fi
          
          # Apply PVCs for file storage
          if [ -f "k8s/pvc/file-uploads-pvc.yaml" ]; then
            echo "üíæ Applying File Storage PVC..."
            kubectl apply -f k8s/pvc/file-uploads-pvc.yaml -n ${{ steps.params.outputs.namespace }} || true
          fi
          
          # Apply Services
          echo "üåê Applying File Service..."
          kubectl apply -f k8s/services/file-service-service.yaml -n ${{ steps.params.outputs.namespace }} || true

      - name: Verify storage resources
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîç Checking storage resources..."
          if kubectl get pvc file-uploads-pvc -n ${{ steps.params.outputs.namespace }} > /dev/null 2>&1; then
            echo "‚úÖ File uploads PVC exists"
            kubectl get pvc file-uploads-pvc -n ${{ steps.params.outputs.namespace }}
          else
            echo "‚ö†Ô∏è File uploads PVC not found - service may fail to start"
          fi

      - name: Deploy File Service
        run: |
          export KUBECONFIG=kubeconfig
          cd k8s-manifests
          
          echo "üöÄ Deploying File Service..."
          
          DEPLOYMENT_FILE=""
          POSSIBLE_PATHS=(
            "k8s/deployments/file-service-deployment.yaml"
            "deployments/file-service-deployment.yaml"
            "manifests/file-service-deployment.yaml"
          )
          
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DEPLOYMENT_FILE="$path"
              break
            fi
          done
          
          kubectl apply -f "$DEPLOYMENT_FILE" -n ${{ steps.params.outputs.namespace }}
          
          echo "‚è≥ Waiting for rollout to complete..."
          kubectl rollout status deployment/file-service -n ${{ steps.params.outputs.namespace }} --timeout=300s

      - name: Verify deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîç Verifying deployment..."
          
          # Check deployment status
          kubectl get deployment file-service -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check pods
          echo "=== Pod Status ==="
          kubectl get pods -l app=file-service -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check service
          echo "=== Service Status ==="
          kubectl get service file-service -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check PVC mount
          echo "=== Storage Status ==="
          kubectl get pvc -n ${{ steps.params.outputs.namespace }}
          
          # Wait for pod to be ready
          kubectl wait --for=condition=ready pod -l app=file-service -n ${{ steps.params.outputs.namespace }} --timeout=120s

      - name: Run health checks
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üè• Running health checks..."
          
          # Test health endpoint
          echo "Testing health endpoint..."
          if kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/file-service -- curl -f http://localhost:7000/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ö†Ô∏è Health check failed, checking logs..."
            kubectl logs -n ${{ steps.params.outputs.namespace }} deployment/file-service --tail=20
            echo "‚ö†Ô∏è Continuing deployment despite health check failure..."
          fi

      - name: Test file operations
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üìÅ Testing file operations..."
          
          # Test root endpoint
          echo "Testing root endpoint..."
          kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/file-service -- curl -f http://localhost:7000/ > /dev/null
          
          # Check if upload directory is accessible
          echo "Checking upload directory..."
          kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/file-service -- ls -la /app/uploads || echo "Upload directory check failed"
          
          # Test database connectivity (if available)
          echo "Testing database connectivity..."
          kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/file-service -- python -c "
          try:
              from main import get_db_connection
              conn = get_db_connection()
              if conn:
                  print('‚úÖ Database connection successful')
                  conn.close()
              else:
                  print('‚ö†Ô∏è Database connection failed')
          except Exception as e:
              print(f'‚ö†Ô∏è Database test error: {e}')
          " || echo "Database test failed"

      - name: Run smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üß™ Running smoke tests..."
          
          # Create a test file for upload simulation
          kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/file-service -- python -c "
          import tempfile
          import os
          # Create test file
          with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False, dir='/tmp') as f:
              f.write('Test file content')
              print(f'Created test file: {f.name}')
              # Check file exists
              if os.path.exists(f.name):
                  print('‚úÖ File operations working')
              else:
                  print('‚ùå File operations failed')
              # Cleanup
              os.unlink(f.name)
          " || echo "Smoke test failed"
          
          echo "‚úÖ Smoke tests completed"

      - name: Deployment summary
        if: always()
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "## üöÄ File Service Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ steps.params.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ steps.params.outputs.full_image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ **Deployment successful!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìä Deployment Status" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get pods -l app=file-service -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üíæ Storage Status" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get pvc -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîç Troubleshooting Info" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get events -n ${{ steps.params.outputs.namespace }} --sort-by='.lastTimestamp' | tail -10 >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

  # Rollback capability
  rollback:
    name: Rollback (Manual)
    runs-on: ubuntu-latest
    if: failure() && github.event.inputs.environment
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          chmod 600 kubeconfig

      - name: Rollback deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          NAMESPACE="${{ github.event.inputs.environment == 'production' && 'bedrock-chat-v2' || 'bedrock-chat-staging' }}"
          
          echo "üîÑ Rolling back File Service deployment..."
          kubectl rollout undo deployment/file-service -n $NAMESPACE
          
          echo "‚è≥ Waiting for rollback to complete..."
          kubectl rollout status deployment/file-service -n $NAMESPACE --timeout=180s
          
          echo "‚úÖ Rollback completed"
